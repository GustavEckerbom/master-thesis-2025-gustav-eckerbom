/******************************************************************************
 * @file     pinconf.h
 * @author   Gustav Eckerbom
 * @email    gustavec@kth.se
 * @version  V1.0.0
 * @date     02-Feb-2023
 * @brief    Pin configuration for ncs custom genx320 board
 ******************************************************************************/

#include "board.h"
#include "clocks.h"
#include "app_map.h"
#include "global_map.h"
#include "Driver_GPIO.h"
#include "pinconf.h"
#include "conductor_board_config.h"
#include "board.h"
#include "uart_tracelib.h"
#include <stdio.h>
#include "board_gpio_handles.h"

#ifndef PORT_
#define _PORT_(n)  PORT_##n
#define  PORT_(n) _PORT_(n)
#endif

#define END_OF_FRAME_GPIO_PORT 12
#define END_OF_FRAME_GPIO_PIN 5
// #define DEVKIT_GEN2

// Button pin

uint32_t config_gpio =
            PADCTRL_READ_ENABLE |
            PADCTRL_SCHMITT_TRIGGER_ENABLE |
            PADCTRL_OUTPUT_DRIVE_STRENGTH_4MA;


void BOARD_pinconf(){
	conductor_pins_config();
}

void button_irq_callback(uint32_t event)
{	
    if (event & ARM_GPIO_IRQ_EVENT_EXTERNAL) {
        BOARD_LED_TOP_GPIO_GPIOdrv->SetValue(BOARD_LED_TOP_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_TOGGLE);
    }
}

uint32_t config_button =
			 PADCTRL_READ_ENABLE |
			 PADCTRL_SCHMITT_TRIGGER_ENABLE |
			 PADCTRL_DRIVER_DISABLED_PULL_UP;

#if defined(BOARD_IS_CUSTOM_VARIANT)

// Set pinmux for the board
void BOARD_Pinmux_Init(){
	uint32_t config_button =    PADCTRL_READ_ENABLE |
                                PADCTRL_SCHMITT_TRIGGER_ENABLE;

    uint32_t irq_cfg =  ARM_GPIO_IRQ_POLARITY_HIGH |
                        ARM_GPIO_IRQ_SENSITIVE_EDGE;

    VSYNC_GPIO_drv->Initialize(BOARD_VSYNC_INTERRUPT_GPIO_PIN, NULL);
    VSYNC_GPIO_drv->PowerControl(BOARD_VSYNC_INTERRUPT_GPIO_PIN, ARM_POWER_FULL);
    VSYNC_GPIO_drv->SetDirection(BOARD_VSYNC_INTERRUPT_GPIO_PIN, GPIO_PIN_DIRECTION_INPUT);

    // Set pinmux to GPIO mode with no pull-up/down
    pinconf_set(PORT_(BOARD_VSYNC_INTERRUPT_GPIO_PORT),
                BOARD_VSYNC_INTERRUPT_GPIO_PIN,
                PINMUX_ALTERNATE_FUNCTION_0,
                config_button);

	// Init the LED GPIOs and header IOs
	BOARD_LED_TOP_GPIO_GPIOdrv->Initialize(BOARD_LED_TOP_GPIO_PIN, NULL);
	BOARD_LED_TOP_GPIO_GPIOdrv->PowerControl(BOARD_LED_TOP_GPIO_PIN, ARM_POWER_FULL);
	BOARD_LED_TOP_GPIO_GPIOdrv->SetDirection(BOARD_LED_TOP_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);

	BOARD_LED_BOT_GPIO_GPIOdrv->Initialize(BOARD_LED_BOT_GPIO_PIN, NULL);
	BOARD_LED_BOT_GPIO_GPIOdrv->PowerControl(BOARD_LED_BOT_GPIO_PIN, ARM_POWER_FULL);
	BOARD_LED_BOT_GPIO_GPIOdrv->SetDirection(BOARD_LED_BOT_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);

	BOARD_IOHEADER_GPIOdrv->Initialize(BOARD_GPIO_PINHEAD_GPIO_PIN, NULL);
	BOARD_IOHEADER_GPIOdrv->PowerControl(BOARD_GPIO_PINHEAD_GPIO_PIN, ARM_POWER_FULL);
	BOARD_IOHEADER_GPIOdrv->SetDirection(BOARD_GPIO_PINHEAD_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_IOHEADER_GPIOdrv->SetValue(BOARD_GPIO_PINHEAD_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);

	// Init the camera module GPIOs
	BOARD_CAM_TRIG_IN_GPIO_GPIOdrv->Initialize(BOARD_CAM_TRIG_IN_GPIO_PIN, NULL);
	BOARD_CAM_TRIG_IN_GPIO_GPIOdrv->PowerControl(BOARD_CAM_TRIG_IN_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_TRIG_IN_GPIO_GPIOdrv->SetDirection(BOARD_CAM_TRIG_IN_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);

	// Set as input for now not to accidentally conflict with camera output
	BOARD_CAM_DGPIO_GPIO_GPIOdrv->Initialize(BOARD_CAM_DGPIO_GPIO_PIN, NULL);
	BOARD_CAM_DGPIO_GPIO_GPIOdrv->PowerControl(BOARD_CAM_DGPIO_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_DGPIO_GPIO_GPIOdrv->SetDirection(BOARD_CAM_DGPIO_GPIO_PIN, GPIO_PIN_DIRECTION_INPUT);

	// ULP pins 2.5 V high and are pulled by external resistors, make sure to configure them as open drain

	// If not they might force the camera module to go into ULP mode if driven to 1.8V by alif GPIO	
	BOARD_CAM_ULP_ENB_GPIO_GPIOdrv->Initialize(BOARD_CAM_ULP_ENB_GPIO_PIN, NULL);
	BOARD_CAM_ULP_ENB_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_ENB_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_ULP_ENB_GPIO_GPIOdrv->SetValue(BOARD_CAM_ULP_ENB_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);
	BOARD_CAM_ULP_ENB_GPIO_GPIOdrv->SetDirection(BOARD_CAM_ULP_ENB_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_CAM_ULP_ENB_GPIO_GPIOdrv->SetValue(BOARD_CAM_ULP_ENB_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);

	BOARD_CAM_ULP_TH_GPIO_GPIOdrv->Initialize(BOARD_CAM_ULP_TH_GPIO_PIN, NULL);
	BOARD_CAM_ULP_TH_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_TH_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_ULP_TH_GPIO_GPIOdrv->SetValue(BOARD_CAM_ULP_TH_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_HIGH);
	BOARD_CAM_ULP_TH_GPIO_GPIOdrv->SetDirection(BOARD_CAM_ULP_TH_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);

	BOARD_CAM_ULP_RST_GPIO_GPIOdrv->Initialize(BOARD_CAM_ULP_RSTN_GPIO_PIN, NULL);
	BOARD_CAM_ULP_RST_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_RSTN_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_ULP_RST_GPIO_GPIOdrv->SetValue(BOARD_CAM_ULP_RSTN_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_HIGH);
	BOARD_CAM_ULP_RST_GPIO_GPIOdrv->SetDirection(BOARD_CAM_ULP_RSTN_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);

	BOARD_CAM_ULP_WAKEUP_GPIO_GPIOdrv->Initialize(BOARD_CAM_ULP_WAKEUP_GPIO_PIN, NULL);
	BOARD_CAM_ULP_WAKEUP_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_WAKEUP_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_ULP_WAKEUP_GPIO_GPIOdrv->SetDirection(BOARD_CAM_ULP_WAKEUP_GPIO_PIN, GPIO_PIN_DIRECTION_INPUT);

	// Camera power reset start in reset
	BOARD_CAM_RESET_GPIO_GPIOdrv->Initialize(BOARD_CAM_RSTN_GPIO_PIN, NULL);
	BOARD_CAM_RESET_GPIO_GPIOdrv->PowerControl(BOARD_CAM_RSTN_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_RESET_GPIO_GPIOdrv->SetValue(BOARD_CAM_RSTN_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);
	BOARD_CAM_RESET_GPIO_GPIOdrv->SetDirection(BOARD_CAM_RSTN_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_CAM_RESET_GPIO_GPIOdrv->SetValue(BOARD_CAM_RSTN_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);

	
	// Camera transmission disable gpio
	BOARD_CAM_PXRSTN_GPIO_GPIOdrv->Initialize(BOARD_CAM_PXRSTN_GPIO_PIN, NULL);
	BOARD_CAM_PXRSTN_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PXRSTN_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_PXRSTN_GPIO_GPIOdrv->SetValue(BOARD_CAM_PXRSTN_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);
	BOARD_CAM_PXRSTN_GPIO_GPIOdrv->SetDirection(BOARD_CAM_PXRSTN_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_CAM_PXRSTN_GPIO_GPIOdrv->SetValue(BOARD_CAM_PXRSTN_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);

	// Board camera power supply enable pins Initialize low so camera is off
	BOARD_CAM_PSU_EN_1V1_GPIO_GPIOdrv->Initialize(BOARD_CAM_PSU_EN_1V1_GPIO_PIN, NULL);
	BOARD_CAM_PSU_EN_1V1_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PSU_EN_1V1_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_PSU_EN_1V1_GPIO_GPIOdrv->SetValue(BOARD_CAM_PSU_EN_1V1_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);
	BOARD_CAM_PSU_EN_1V1_GPIO_GPIOdrv->SetDirection(BOARD_CAM_PSU_EN_1V1_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_CAM_PSU_EN_1V1_GPIO_GPIOdrv->SetValue(BOARD_CAM_PSU_EN_1V1_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);

	BOARD_CAM_PSU_EN_1V8_GPIO_GPIOdrv->Initialize(BOARD_CAM_PSU_EN_1V8_GPIO_PIN, NULL);
	BOARD_CAM_PSU_EN_1V8_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PSU_EN_1V8_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_PSU_EN_1V8_GPIO_GPIOdrv->SetValue(BOARD_CAM_PSU_EN_1V8_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);
	BOARD_CAM_PSU_EN_1V8_GPIO_GPIOdrv->SetDirection(BOARD_CAM_PSU_EN_1V8_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_CAM_PSU_EN_1V8_GPIO_GPIOdrv->SetValue(BOARD_CAM_PSU_EN_1V8_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);

	BOARD_CAM_PSU_EN_2V5_GPIO_GPIOdrv->Initialize(BOARD_CAM_PSU_EN_2V5_GPIO_PIN, NULL);
	BOARD_CAM_PSU_EN_2V5_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PSU_EN_2V5_GPIO_PIN, ARM_POWER_FULL);
	BOARD_CAM_PSU_EN_2V5_GPIO_GPIOdrv->SetValue(BOARD_CAM_PSU_EN_2V5_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);
	BOARD_CAM_PSU_EN_2V5_GPIO_GPIOdrv->SetDirection(BOARD_CAM_PSU_EN_2V5_GPIO_PIN, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_CAM_PSU_EN_2V5_GPIO_GPIOdrv->SetValue(BOARD_CAM_PSU_EN_2V5_GPIO_PIN, GPIO_PIN_OUTPUT_STATE_LOW);
}


// Deinit disable IRQs, power OFF, and reqconfigure the ULP pins to high Z 
void BOARD_Pinmux_Deinit_PD6_Off(void)
{
	// -- VSYNC GPIO --
	VSYNC_GPIO_drv->PowerControl(BOARD_VSYNC_INTERRUPT_GPIO_PIN, ARM_POWER_OFF);
	VSYNC_GPIO_drv->Uninitialize(BOARD_VSYNC_INTERRUPT_GPIO_PIN);

    // --- LEDs ---
    BOARD_LED_TOP_GPIO_GPIOdrv->PowerControl(BOARD_LED_TOP_GPIO_PIN, ARM_POWER_OFF);
    BOARD_LED_TOP_GPIO_GPIOdrv->Uninitialize(BOARD_LED_TOP_GPIO_PIN);

    BOARD_LED_BOT_GPIO_GPIOdrv->PowerControl(BOARD_LED_BOT_GPIO_PIN, ARM_POWER_OFF);
    BOARD_LED_BOT_GPIO_GPIOdrv->Uninitialize(BOARD_LED_BOT_GPIO_PIN);

    // --- IO header ---
    BOARD_IOHEADER_GPIOdrv->PowerControl(BOARD_GPIO_PINHEAD_GPIO_PIN, ARM_POWER_OFF);
    BOARD_IOHEADER_GPIOdrv->Uninitialize(BOARD_GPIO_PINHEAD_GPIO_PIN);

    // --- Camera GPIOs (no state changes; just OFF + Uninit) ---
    BOARD_CAM_TRIG_IN_GPIO_GPIOdrv->PowerControl(BOARD_CAM_TRIG_IN_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_TRIG_IN_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_TRIG_IN_GPIO_PIN);

	pinconf_set(BOARD_CAM_DGPIO_GPIO_PORT, BOARD_CAM_DGPIO_GPIO_PIN, PINMUX_ALTERNATE_FUNCTION_0, PADCTRL_DRIVER_DISABLED_HIGH_Z);
    BOARD_CAM_DGPIO_GPIO_GPIOdrv->PowerControl(BOARD_CAM_DGPIO_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_DGPIO_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_DGPIO_GPIO_PIN);

	pinconf_set(BOARD_CAM_ULP_ENB_GPIO_PORT, BOARD_CAM_ULP_ENB_GPIO_PIN, PINMUX_ALTERNATE_FUNCTION_0, PADCTRL_DRIVER_DISABLED_HIGH_Z);
    BOARD_CAM_ULP_ENB_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_ENB_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_ULP_ENB_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_ULP_ENB_GPIO_PIN);

	pinconf_set(BOARD_CAM_ULP_TH_GPIO_PORT, BOARD_CAM_ULP_TH_GPIO_PIN, PINMUX_ALTERNATE_FUNCTION_0, PADCTRL_DRIVER_DISABLED_HIGH_Z);
    BOARD_CAM_ULP_TH_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_TH_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_ULP_TH_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_ULP_TH_GPIO_PIN);
	
	pinconf_set(BOARD_CAM_ULP_RSTN_GPIO_PORT, BOARD_CAM_ULP_RSTN_GPIO_PIN, PINMUX_ALTERNATE_FUNCTION_0, PADCTRL_DRIVER_DISABLED_HIGH_Z);
    BOARD_CAM_ULP_RST_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_RSTN_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_ULP_RST_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_ULP_RSTN_GPIO_PIN);

	pinconf_set(BOARD_CAM_ULP_WAKEUP_GPIO_PORT, BOARD_CAM_ULP_WAKEUP_GPIO_PIN, PINMUX_ALTERNATE_FUNCTION_0, PADCTRL_DRIVER_DISABLED_HIGH_Z);
    BOARD_CAM_ULP_WAKEUP_GPIO_GPIOdrv->PowerControl(BOARD_CAM_ULP_WAKEUP_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_ULP_WAKEUP_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_ULP_WAKEUP_GPIO_PIN);

	pinconf_set(BOARD_CAM_RSTN_GPIO_PORT, BOARD_CAM_RSTN_GPIO_PIN, PINMUX_ALTERNATE_FUNCTION_0, PADCTRL_DRIVER_DISABLED_HIGH_Z);
    BOARD_CAM_RESET_GPIO_GPIOdrv->PowerControl(BOARD_CAM_RSTN_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_RESET_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_RSTN_GPIO_PIN);

    BOARD_CAM_PXRSTN_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PXRSTN_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_PXRSTN_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_PXRSTN_GPIO_PIN);

    BOARD_CAM_PSU_EN_1V1_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PSU_EN_1V1_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_PSU_EN_1V1_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_PSU_EN_1V1_GPIO_PIN);

    BOARD_CAM_PSU_EN_1V8_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PSU_EN_1V8_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_PSU_EN_1V8_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_PSU_EN_1V8_GPIO_PIN);

    BOARD_CAM_PSU_EN_2V5_GPIO_GPIOdrv->PowerControl(BOARD_CAM_PSU_EN_2V5_GPIO_PIN, ARM_POWER_OFF);
    BOARD_CAM_PSU_EN_2V5_GPIO_GPIOdrv->Uninitialize(BOARD_CAM_PSU_EN_2V5_GPIO_PIN);
}


// Call only for devkit gen2 
void BOARD_UART_Init(){
		uint32_t config_input =
				PADCTRL_READ_ENABLE |
				PADCTRL_SCHMITT_TRIGGER_ENABLE;
	 
		uint32_t config_uart_rx =
				PADCTRL_READ_ENABLE |
				PADCTRL_SCHMITT_TRIGGER_ENABLE |
				PADCTRL_DRIVER_DISABLED_PULL_UP;
		  
		/* UART2 interface */
		pinconf_set(PORT_1, PIN_0, PINMUX_ALTERNATE_FUNCTION_1, config_uart_rx);	// P1_0: RX  (mux mode 1)
		pinconf_set(PORT_1, PIN_1, PINMUX_ALTERNATE_FUNCTION_1, 0);					// P1_1: TX  (mux mode 1)
	}
#elif defined(BOARD_IS_ALIF_DEVKIT_B0_VARIANT)
// Set pinmux for the board
void BOARD_Pinmux_Init(){

	uint32_t config_gpio =
	PADCTRL_READ_ENABLE |
	PADCTRL_SCHMITT_TRIGGER_ENABLE |
	PADCTRL_OUTPUT_DRIVE_STRENGTH_4MA;

	// LED pins
	extern ARM_DRIVER_GPIO ARM_Driver_GPIO_(BOARD_LEDRGB0_G_GPIO_PORT);
	ARM_DRIVER_GPIO *BOARD_LED_TOP_GPIO_GPIOdrv = &ARM_Driver_GPIO_(BOARD_LEDRGB0_G_GPIO_PORT);
	BOARD_LED_TOP_GPIO_GPIOdrv->Initialize(BOARD_LEDRGB0_G_PIN_NO, NULL);
	BOARD_LED_TOP_GPIO_GPIOdrv->PowerControl(BOARD_LEDRGB0_G_PIN_NO, ARM_POWER_FULL);
	BOARD_LED_TOP_GPIO_GPIOdrv->SetDirection(BOARD_LEDRGB0_G_PIN_NO, GPIO_PIN_DIRECTION_OUTPUT);
	BOARD_LED_TOP_GPIO_GPIOdrv->SetValue(BOARD_LEDRGB0_G_PIN_NO, GPIO_PIN_OUTPUT_STATE_LOW);
	pinconf_set(PORT_(BOARD_LEDRGB0_G_GPIO_PORT), BOARD_LEDRGB0_G_PIN_NO, PINMUX_ALTERNATE_FUNCTION_0, config_gpio);
}

void BOARD_UART_Init(){
	uint32_t config_input =
			PADCTRL_READ_ENABLE |
			PADCTRL_SCHMITT_TRIGGER_ENABLE;
 
	uint32_t config_uart_rx =
			PADCTRL_READ_ENABLE |
			PADCTRL_SCHMITT_TRIGGER_ENABLE |
			PADCTRL_DRIVER_DISABLED_PULL_UP;
	  
	/* UART2 interface */
	pinconf_set(PORT_1, PIN_0, PINMUX_ALTERNATE_FUNCTION_1, config_uart_rx);	// P1_0: RX  (mux mode 1)
	pinconf_set(PORT_1, PIN_1, PINMUX_ALTERNATE_FUNCTION_1, 0);					// P1_1: TX  (mux mode 1)
}

#endif

void BOARD_Clock_Init()
{
	/* Configure any SoC clock muxes and dividers
	 * if not already covered in driver code
	 */

	/* CFGPER0 Registers */
	/* CFGPER0_BASE
	 * ipclk_force[31] set to 1 to force peripheral clocks on
	 * pclk_force[30] set to 1 to force interface clocks (PCLK) on
	 */
  	// HW_REG32(CFGPER0_BASE, 0) = (1U << 31) | (1U << 30);

    /* Camera pixel clock (XVCLK) control
     * camera_pixclk_ctrl.divider[24:16] up to 0x1FF
     * camera_pixclk_ctrl.select[4] 0: 400 or 1: 480
     * camera_pixclk_ctrl.enable[0]
     */
  	//HW_REG32(CAMERA_PIXCLK_CTRL, 0) = (32U << 16) | (0U << 4) | 1U;

    /* CGU Registers */
    /* OSC Control Register
     * sys_xtal_sel[0] 0: 76P8 HFRC, 1: 38P4 HFXO
     * SYS_REFCLK, SYSPLL, CPUPLL
     *
     * periph_xtal_sel[4] 0: 76P8 HFRC, 1: 38P4 HFXO
     * SYS_UART, MRAM_EFUSE, I2S, CAN_FD, MIPI, ES0, ES1
     *
     * clkmon_ena[16] 0: disable 1: enable HFXO clock monitor
     * xtal_dead[20] read-only status of HFXO clock monitor
     */
  //HW_REG32(CLOCKGEN_BASE, 0x00) &= ~(1U | 1U << 4);
  //HW_REG32(CLOCKGEN_BASE, 0x00) |=  (1U | 1U << 4);

    /* CLK Enable Register
     * hfxo[18] output of sys_xtal_clk (76P8 HFRC or 38P4 HFXO)
     * clk160M [20]
     * clk100M [21]
     * clk20M  [22]
     * clk38p4M[23]
     */
  //HW_REG32(CLOCKGEN_BASE, 0x14) |=  1U << 18;
  //HW_REG32(CLOCKGEN_BASE, 0x14) |= 15U << 20;

  //HW_REG32(VBATREGS_SE, 0) = 0;               // 0: 32.768kHz LFRC, 1: 32.768kHz LFXO/* Enable Peripheral Clocks 
}

void BOARD_Power_Init()
{
	/* Configure any board level power supplies */

#if 0
	/* BOARD_LCD_BACKLIGHT_GPIO_PORT */
	extern ARM_DRIVER_GPIO ARM_Driver_GPIO_(BOARD_LCD_BACKLIGHT_GPIO_PORT);
	ARM_DRIVER_GPIO *LCD_BACKLIGHT_POWER_GPIO = &ARM_Driver_GPIO_(BOARD_LCD_BACKLIGHT_GPIO_PORT);

	LCD_BACKLIGHT_POWER_GPIO->Initialize(BOARD_LCD_BACKLIGHT_PIN_NO, NULL);
	LCD_BACKLIGHT_POWER_GPIO->PowerControl(BOARD_LCD_BACKLIGHT_PIN_NO,  ARM_POWER_FULL);
	LCD_BACKLIGHT_POWER_GPIO->SetValue(BOARD_LCD_BACKLIGHT_PIN_NO, GPIO_PIN_OUTPUT_STATE_HIGH);
	LCD_BACKLIGHT_POWER_GPIO->SetDirection(BOARD_LCD_BACKLIGHT_PIN_NO, GPIO_PIN_DIRECTION_OUTPUT);
#endif
}

/*
void BOARD_BUTTON1_Init(BOARD_Callback_t user_cb)
{
	ARM_DRIVER_GPIO *BOARD_BUTTON1_GPIOdrv = &ARM_Driver_GPIO_(BOARD_BUTTON1_GPIO_PORT);
	BOARD_BUTTON1_GPIOdrv->Initialize(BOARD_BUTTON1_PIN_NO, user_cb);
}

void BOARD_BUTTON2_Init(BOARD_Callback_t user_cb)
{
	ARM_DRIVER_GPIO *BOARD_BUTTON2_GPIOdrv = &ARM_Driver_GPIO_(BOARD_BUTTON2_GPIO_PORT);
	BOARD_BUTTON2_GPIOdrv->Initialize(BOARD_BUTTON2_PIN_NO, user_cb);
}

void BOARD_BUTTON1_Control(BOARD_BUTTON_CONTROL control)
{
	uint32_t arg = ARM_GPIO_IRQ_POLARITY_LOW | ARM_GPIO_IRQ_SENSITIVE_EDGE;

	ARM_DRIVER_GPIO *BOARD_BUTTON1_GPIOdrv = &ARM_Driver_GPIO_(BOARD_BUTTON1_GPIO_PORT);
	BOARD_BUTTON1_GPIOdrv->Control(BOARD_BUTTON1_PIN_NO, (GPIO_OPERATION) control, &arg);
}

void BOARD_BUTTON2_Control(BOARD_BUTTON_CONTROL control)
{
	uint32_t arg = ARM_GPIO_IRQ_POLARITY_LOW | ARM_GPIO_IRQ_SENSITIVE_EDGE;

	ARM_DRIVER_GPIO *BOARD_BUTTON2_GPIOdrv = &ARM_Driver_GPIO_(BOARD_BUTTON2_GPIO_PORT);
	BOARD_BUTTON2_GPIOdrv->Control(BOARD_BUTTON2_PIN_NO, (GPIO_OPERATION) control, &arg);
}

void BOARD_BUTTON1_GetState(BOARD_BUTTON_STATE *state)
{
	ARM_DRIVER_GPIO *BOARD_BUTTON1_GPIOdrv = &ARM_Driver_GPIO_(BOARD_BUTTON1_GPIO_PORT);
	uint32_t value;
	BOARD_BUTTON1_GPIOdrv->GetValue(BOARD_BUTTON1_PIN_NO, &value);
	*state = (BOARD_BUTTON_STATE)value;
}

void BOARD_BUTTON2_GetState(BOARD_BUTTON_STATE *state)
{
	ARM_DRIVER_GPIO *BOARD_BUTTON2_GPIOdrv = &ARM_Driver_GPIO_(BOARD_BUTTON2_GPIO_PORT);
	uint32_t value;
	BOARD_BUTTON2_GPIOdrv->GetValue(BOARD_BUTTON2_PIN_NO, &value);
	*state = (BOARD_BUTTON_STATE)value;
}

void BOARD_LED1_Control(BOARD_PIN_OUTPUT_STATE state)
{
	ARM_DRIVER_GPIO *BOARD_LED1_GPIOdrv = &ARM_Driver_GPIO_(BOARD_LED1_GPIO_PORT);
	BOARD_LED1_GPIOdrv->SetValue(BOARD_LED1_PIN_NO, (GPIO_PIN_OUTPUT_STATE) state);
}

void BOARD_LED2_Control(BOARD_PIN_OUTPUT_STATE state)
{
	ARM_DRIVER_GPIO *BOARD_LED2_GPIOdrv = &ARM_Driver_GPIO_(BOARD_LED2_GPIO_PORT);
	BOARD_LED2_GPIOdrv->SetValue(BOARD_LED2_PIN_NO, (GPIO_PIN_OUTPUT_STATE) state);
}

*/
